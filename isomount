#!/bin/bash

VERSION="00.04.00"
VERSION_DATE="Wed Mar 28 18:31:14 MDT 2018"

MY_NAME=${0##*/}
ME=${ACTION:=$MY_NAME}

 MAX_DIRS=20

  MNT_DIR="/mnt/iso"
 ISO_NAME="iso"
  SQ_NAME="sq"
  SQ_FILE="antiX/linuxfs"
: ${HEADER_TYPE:=rev2}

         YAD="/usr/bin/yad"
   YAD_IMAGE="/usr/local/lib/antiX/antiX-logo.png"
YAD_STD_OPTS="--center --width=900 --height=600 --button=gtk-ok:0 "
YAD_ERR_OPTS="--center --width=800 --height=300 --button=gtk-ok:0 "

if test -r $YAD_IMAGE; then
    YAD_STD_OPTS="$YAD_STD_OPTS -image=$YAD_IMAGE"
    YAD_ERR_OPTS="$YAD_STD_OPTS -image=$YAD_IMAGE"

SCREEN_WIDTH=$(stty size | cut -d" " -f2)
#------------------------------------------------------------------------------
#
#
#------------------------------------------------------------------------------
SUDO="sudo"
[ $UID -eq 0 ] && SUDO=

iso_mount_usage() {
    local fname=$MNT_DIR/${ISO_NAME}1
    cat <<Usage
${bold_co}Usage:${m_co} $ME [options] iso-file-1 [iso-file-2 ...]${nc_co}
    Mount the iso files specified at directories like $fname.  For
    antiX and MX iso files then also mount the /$SQ_FILE squashfs file.
Usage
    opt_usage
}

#------------------------------------------------------------------------------
#
#
#------------------------------------------------------------------------------
sq_mount_usage() {
    local fname=$MNT_DIR/${SQ_NAME}1
    cat <<Usage
${bold_co}Usage:${m_co} $ME [options] squashfs-1 [squashfs-2 ...]${nc_co}
    Mount the squashfs file(s) specified at a directory like $fname/
Usage
    opt_usage
}

#------------------------------------------------------------------------------
#
#
#------------------------------------------------------------------------------
iso_umount_usage() {
    local fname=$MNT_DIR/${ISO_NAME}N
    cat <<Usage
${bold_co}Usage:${m_co} $ME [options] [$fname|'all']${nc_co}
    Umount the most recently mounted iso file.  If a mountpoint is
    given then unmount that mountpoint instead.

    If 'all' is given then unmount all of our mounts.
Usage
    opt_usage
}

#------------------------------------------------------------------------------
#
#
#------------------------------------------------------------------------------
sq_umount_usage() {
    local fname=$MNT_DIR/${SQ_NAME}N
    cat <<Usage
${bold_co}Usage:${m_co} $ME [options] [$fname|'all']${nc_co}
    Umount the most recently mounted squashfs file.  If a mountpoint is
    given then unmount that mountpoint instead.  In both cases we also
    delete the mountpoint directory and the $fname@<name> file.

    If 'all' is given then unmount all of our mounts.
Usage
    opt_usage
}

#------------------------------------------------------------------------------
#
#
#------------------------------------------------------------------------------
clean_usage() {
    cat <<Usage
${bold_co}Usage:${m_co} $ME [options]${nc_co}
    Clean up leftover mountpoint directories and @ files.
Usage
    opt_usage
}

#------------------------------------------------------------------------------
#
#
#------------------------------------------------------------------------------
show_nounts_usage() {
    cat <<Usage
${bold_co}Usage:${m_co} $ME [options]${nc_co}
    Show the currently mounted iso and squashfs files
Usage
    opt_usage
}

opt_usage() {
    [ "$DONT_SHOW_OPTS" ] && return
    cat <<Usage

${bold_co}Options:$nc_co
    $m_co-c --color=<xxx>  $nc_co set color scheme to off|low|low2|bw|dark|high
    $m_co-g --gui          $nc_co show output in a yad window
    $m_co-h --help         $nc_co show this usage
    $m_co-H --header=<type>  $nc_co change header color: norm, rev1, rev2, rev3
                                             (n,      r1,   r2,   r3)
    $m_co-q --quiet        $nc_co only show mountpoints
    $m_co-Q --Quiet        $nc_co don't show mountpoint(s)
    $m_co-s --silent       $nc_co don't print error message
    $m_co-v --version      $nc_co show version number and exit
    $m_co-V --verbose      $nc_co be more verbose
Usage
}

#------------------------------------------------------------------------------
#
#
#------------------------------------------------------------------------------
usage() {

    show_version
    printf "\n"

    if [ "$1" == 'all' ]; then
        DONT_SHOW_OPTS=true
        iso_mount_usage    ; echo
        sq_mount_usage     ; echo
        iso_umount_usage   ; echo
        sq_umount_usage    ; echo
        clean_usage        ; echo
        show_mounts_usage  ; echo

        DONT_SHOW_OPTS=
        opt_usage
        exit 0
    fi

    case $ME in
             isomount) iso_mount_usage     ;;
              sqmount) sq_mount_usage      ;;
            isoumount) iso_umount_usage    ;;
             squmount) sq_umount_usage     ;;
       clean-isomount) clean_usage         ;;
        show-isomount) show_moounts_usage  ;;
                    *) fatal "Unknown program name %s" $ME ;;
    esac


    exit 0
}

#------------------------------------------------------------------------------
#
#
#------------------------------------------------------------------------------
takes_param() {
    case $1 in
        -color|c) return 0 ;;
       -header|H) return 0 ;;
               *) return 1 ;;
    esac
}

#------------------------------------------------------------------------------
#
#
#------------------------------------------------------------------------------
assign_parameter() {
    local cnt=$1 param=$2
    CMD_CMDS="$CMD_CMDS${CMD_CMDS:+\n}$param"
}

#------------------------------------------------------------------------------
#
#
#------------------------------------------------------------------------------
eval_argument() {
    local arg=$1  val=$2
    case $arg in
         -color|c)  COLOR_SCHEME=$val   ;;
         -color=*)  COLOR_SCHEME=$val   ;;
           -gui|g)  GUI_MODE=true       ;;
          -help|h)  DO_HELP=true        ;;
        -header|H)  HEADER_TYPE=$val    ;;
        -header=*)  HEADER_TYPE=$val    ;;

         -quiet|q)  ONLY_MPS=true       ;;
         -Quiet|Q)  NO_MPS=true         ;;
        -silent|s)  BE_SILENT=true      ;;
       -version|v)  SHOW_VERSION=true   ;;
       -verbose|V)  BE_VERBOSE=true     ;;
                *)  fatal "Unknown parameter %s" "-$arg"  ;;
    esac
}

#------------------------------------------------------------------------------
#
#
#------------------------------------------------------------------------------
main() {
    local SHIFT SHIFT_2  SHORT_STACK="HhQqsVv"
    local NO_MPS ONLY_MPS  BE_SILENT BE_VERBOSE  PARAM_CNT
    local GUI_TEXT

    set_colors
    read_all_cmdline_mingled "$@"
    shift $SHIFT_2

    [ -z "$SCREEN_WIDTH"  -o "$SCREEN_WIDTH" = 0 ] && GUI_MODE=true

    if [ "$GUI_MODE" ]; then
        set_colors gui
    else
        set_colors $COLOR_SCHEME
    fi

    local max_param=0  min_param=0 base=$ME
    case $base in
          isomount|sqmount)  max_param=20  ; min_param=1 ;;
        isoumount|squmount)  max_param=1                 ;;
    esac

    case $base in
             isomount)   ;;
              sqmount)   ;;
            isoumount)   ;;
             squmount)   ;;
       clean-isomount)   ;;
        show-isomount)   ;;
                    *) fatal "Unknown program name %s" $ME ;;
    esac

    case $HEADER_TYPE in
        norm|rev[123]|n|r[123]) ;;
                    *) fatal "Unknown header type: %s" "$HEADER_TYPE"
    esac

    [ "$DO_HELP" ]      && usage "$CMD_CMDS"
    [ "$SHOW_VERSION" ] && show_version 'exit'

    [ "$BE_VERBOSE" ] && show_version
    [ $PARAM_CNT -lt $min_param ] && usage
    [ $PARAM_CNT -gt $max_param ] && fatal "Too many command line parameters"
    case $base in
             isomount)  do_iso_mount  "$CMD_CMDS"           ;;
              sqmount)  do_sq_mount   "$CMD_CMDS"           ;;
            isoumount)  do_iso_umount "$CMD_CMDS"           ;;
             squmount)  do_sq_umount  "$CMD_CMDS"           ;;
       clean-isomount)  clean_mounts                        ;;
        show-isomount)  show_mounts ; exit 0                ;;
                    *)  fatal "Unknown program name %s" $ME ;;
    esac

    [ -z "$NO_MPS" ] && show_mounts
    exit 0
}

#------------------------------------------------------------------------------
#
#
#------------------------------------------------------------------------------
do_iso_mount() {
    local data=$1  file
    while read file; do
        [ -z "$file" ] && continue
        any_mount "$ISO_NAME" "$file" -o loop,user,ro,exec -t iso9660
    done <<Do_Iso_Mount
$(echo -e "$data")
Do_Iso_Mount
}

#------------------------------------------------------------------------------
#
#
#------------------------------------------------------------------------------
do_sq_mount() {
    local data=$1  file
    while read file; do
        [ -z "$file" ] && continue
        any_mount "$SQ_NAME" "$file" -o loop,user,ro,exec -t squashfs
    done <<Do_Sq_Mount
$(echo -e "$data")
Do_Sq_Mount
}

#------------------------------------------------------------------------------
#
#
#------------------------------------------------------------------------------
do_iso_umount() {
    local name=$ISO_NAME  where=$1
    any_umount "$name" $where
}

#------------------------------------------------------------------------------
#
#
#------------------------------------------------------------------------------
do_sq_umount() {
    local name=$SQ_NAME  Ewhere=$1
    any_umount "$name" $where
}

#------------------------------------------------------------------------------
#
#
#------------------------------------------------------------------------------
any_mount() {
    verbose "any_mount(%s)" "$bold_co$*$quest_co"

    local name=$1  what=$2    where  n; shift 2
    [ -z "$what" ]  && fatal "Need to say what we should %s"   "$ME"

    test -e "$what" || fatal "Can not find file: %s"           "$what"
    test -f "$what" || fatal "%s does not appear to be a file" "$what"

    if ! mountpoint -q "$MNT_DIR"; then
        $SUDO mkdir -p "$MNT_DIR"
        $SUDO mount -t tmpfs -o size=1m tmpfs "$MNT_DIR"
        mountpoint -q "$MNT_DIR" || fatal "Could not mount %s as %s"  "$MNT_DIR" 'tmpfs'
    fi
    for n in $(seq 1 $MAX_DIRS); do
        where=$MNT_DIR/$name$n
        mountpoint -q "$where" || break
    done
    mountpoint -q  "$where" && fatal "Mount point %s and below are already taken" "$where"

    local mp=${where##*/}

    $SUDO mkdir -p "$where" || fatal "Could not create the directory %s" "$where"
    $SUDO mount "$@" "$what" "$where"

    if ! mountpoint -q "$where"; then
        $SUDO rmdir "$where"
        fatal "Was unable to mount %s" "$* $what $where"
    fi

    say "Mounted %s at %s" "$hi_co$what$m_co" "$hi_co$where$m_co"

    local sq_file=$where/$SQ_FILE
    [ "$name" == "$ISO_NAME" -a -e "$sq_file" ] || return
    do_sq_mount "$sq_file"
}

#------------------------------------------------------------------------------
#
#
#------------------------------------------------------------------------------
any_umount() {
    verbose "any_umount(%s)" "$bold_co$*$quest_co"
    local name=$1  where=$2
    if [ "$where" == 'all' ]; then
        local mp i is_done
        for i in $(seq 1 3); do
            is_done=true
            for mp in $(df -a | sed "s/.* //" | grep "^$MNT_DIR/" | tac); do
                mountpoint -q $mp || continue
                local what=$(mp_to_file "$where")
                $SUDO umount $mp

                if mountpoint -q $mp; then
                    is_done=
                else
                    $SUDO rmdir   "$mp"
                    say_unmounted "$mp" "$what"
                fi
            done
            [ "$is_done" ] && break
        done
        return

    elif [ -n "$where" ]; then
        mountpoint -q "$where" || fatal "%s is not a mountpoint" "$where"
        name=${where##*/}
        name=${name%%[0-9]*}
        case $name in
            $ISO_NAME|$SQ_NAME) ;;
            *) fatal "Unrecognized name %s" "$name" ;;
        esac

    else
        local n
        for n in $(seq $MAX_DIRS -1 1); do
            where=$MNT_DIR/$name$n
            mountpoint -q "$where" && break
        done
        mountpoint -q "$where" || fatal "No %s mountpoints found" "$name"

    fi
    local sq_file=$where/$SQ_FILE

    if [ "$name" == "$ISO_NAME" -a -e "$sq_file" ]; then

        local sq_mp
        for sq_mp in $(files_to_loops_to_mps $where); do
            mountpoint -q "$sq_mp" && do_umount "$sq_mp"
        done
    fi

    do_umount "$where"
}

#------------------------------------------------------------------------------
#
#
#------------------------------------------------------------------------------
do_umount() {
    verbose "do_umount(%s)" "$bold_co$*$quest_co"
    local where=$1
    local what=$(mp_to_file $where)
	$SUDO umount  "$where"
	mountpoint -q "$where" && fatal "Failed to umount %s" "$where"
	$SUDO rmdir   "$where" || fatal "Failed to remove %s directory" "$where"

    say_unmounted "$where" "$what"
}

#------------------------------------------------------------------------------
#
#
#------------------------------------------------------------------------------
say_unmounted() {
    local where=$1  what=$2
    if [ -n "$what" ]; then
        say "Unmounted %s (%s)" "$hi_co$where$m_co" "$hi_co$what$m_co"
    else
        say "Unmounted %s" "$hi_co$where$m_co"
    fi
}


#------------------------------------------------------------------------------
#
#
#------------------------------------------------------------------------------
fatal() {
    local fmt=$1 ; shift
    if [ -z "$BE_SILENT" ]; then
        [ "$GUI_MODE" ] && error_box "$(printf "$fmt%s" "$@" '\n')"
        printf "$ME: $warn_co$fmt$nc_co\n" "$@" >&2
    fi
    exit 2
}

#------------------------------------------------------------------------------
#
#
#------------------------------------------------------------------------------
say() {
    local fmt=$1 ; shift

    [ "$ONLY_MPS" ] && return
    [ "$GUI_MODE" ] && GUI_TEXT="$GUI_TEXT$(printf "$fmt%s"  "$@" '\n')"
    printf "$ME: $m_co$fmt$nc_co\n" "$@"
}

#------------------------------------------------------------------------------
#
#
#------------------------------------------------------------------------------
verbose() {
    [ "$BE_VERBOSE" ] || return
    local fmt=$1 ; shift
    printf "$ME: $quest_co$fmt$nc_co\n" "$@"
}

#------------------------------------------------------------------------------
# Show the mount points we have created together with the file that is mounted
# and type and size. We go through the list of mount points twice.  The first
# time we get the maximum width so everything lines up nice and neat.
#
# I should truncate the file names if we don't fit the screen and I should
# add colors.
#------------------------------------------------------------------------------
show_mounts() {
    local data=$(df -ahT | grep -E " $MNT_DIR/($ISO_NAME|$SQ_NAME)[0-9]")

    local lab_type="Type"
    local lab_file="File"
    local lab_size="Size"
    local lab_mp="Mounted at"

    local dev type size used avail percent mp file
    [ "$GUI_MODE" ] && show_mounts_gui "$data"

    [ -z "$data" -o -n "$GUI_MODE" ] && return

    local w_type=${#lab_type}  w_size=${#lab_size}  w_mp=${#lab_mp} w_file=${#lab_file}
    while read dev type size used avail percent mp; do
        [ ${#dev} -gt 0   ] || continue
        local file=$(loop_to_file $dev)
        [ $w_file -lt ${#file} ] && w_file=${#file}
        [ $w_type -lt ${#type} ] && w_type=${#type}
        [ $w_size -lt ${#size} ] && w_size=${#size}
        [ $w_mp -lt ${#mp} ] && w_mp=${#mp}
    done <<Show_Mounts
$(echo "$data")
Show_Mounts


    local clip_mp
    if [ $SCREEN_WIDTH -lt $((w_file + w_type + w_size + w_mp + 6)) ]; then
        clip_mp=true
        lab_mp="MntPnt"
        w_mp=$((w_mp - ${#MNT_DIR} -1))
        [ $w_mp -lt ${#w_lab} ] && w_mp=${w_mp}
    fi
    local truncate=$((w_file + w_type + w_size + w_mp - SCREEN_WIDTH + 6))
    if [ $truncate -gt 0 ]; then
        w_file=$((w_file - truncate))
        [ $w_file -lt ${#lab_file} ] && fatal "The screen appears to be way too narrow!"
    fi

    printf "\n"

    local h_co=$head_co$rev_co hfmt hfmt1 hfmt1
    local h1=
    case $HEADER_TYPE in norm|n) h_co=$head_co  ;; esac

    hfmt1="$h_co%-${w_file}s  %-${w_type}s  %${w_size}s  %-${w_mp}s$nc_co\n"
    hfmt2="$h_co%-${w_file}s$nc_co  $h_co%-${w_type}s$nc_co  $h_co%${w_size}s$nc_co  $h_co%-${w_mp}s$nc_co\n"

    hfmt=$hfmt1
    case $HEADER_TYPE in
          rev2|r2) hfmt=$hfmt2 ;;
    esac

    case $HEADER_TYPE in
        rev3|r3)
            printf "$h_co%s  "   "$(rpad $w_file  "$lab_file$nc_co"  )"
            printf "$h_co%s  "   "$(rpad $w_type  "$lab_type$nc_co"  )"
            printf "$h_co%s  "   "$(lpad $w_size  "$lab_size$nc_co"  )"
            printf "$h_co%s\n"   "$lab_mp$nc_co"  ;;
        *)
            printf "$hfmt" "$lab_file"  "$lab_type" "$lab_size" "$lab_mp" ;;
    esac

    local fmt="$dev_co%-${w_file}s  $warn_co%-${w_type}s  $num_co%${w_size}s  $m_co%-${w_mp}s$nc_co\n"

    while read dev type size used avail percent mp; do
        [ ${#dev} -gt 0   ] || continue
        file=$(loop_to_file $dev)
        [ "$clip_mp" ] && mp=${mp#$MNT_DIR/}
        file=$(my_truncate "$w_file" "$file")
        printf "$fmt" "$file" "$type" "$size" "$mp"
    done <<Show_Mounts
$(echo "$data")
Show_Mounts
}

#------------------------------------------------------------------------------
#
#
#------------------------------------------------------------------------------
show_mounts_gui() {
    local data=$1
    device_info "$data" | $YAD $YAD_STD_OPTS \
        --title "$ME"        \
        --text "$GUI_TEXT"   \
        --list               \
        --column="$lab_file" \
        --column="$lab_type" \
        --column="$lab_size" \
        --column="$lab_mp"
        #2>/dev/null

    exit 0
}

device_info() {
    local data="$1"

    while read dev type size used avail percent mp; do
        [ ${#dev} -gt 0   ] || continue
        file=$(loop_to_file $dev)
        echo -e "$file\n$type\n$size\n$mp"
    done <<Device_Info
$(echo "$data")
Device_Info
}

#------------------------------------------------------------------------------
#
#
#------------------------------------------------------------------------------
error_box() {
    local text=$(printf "\n\n%s\n\n" "$*")
    $YAD $YAD_ERR_OPTS --title "$ME"  --text "$text"
    exit 2
}

#------------------------------------------------------------------------------
# Get the loopback back-file associated with the given mountpoint
#------------------------------------------------------------------------------
mp_to_file() {
    local where=$1
    local loop=$(df -a | grep -E "^([^ ]+ +){5}$where$" | sed "s/ .*//")
    [ -z "$loop" ] && return
    loop_to_file "$loop"
}

#------------------------------------------------------------------------------
# Get the filename associated with the given loopback device
#------------------------------------------------------------------------------
loop_to_file() {
    local dev=$1
    losetup -nl -O name,back-file | grep "^$dev " | sed -r "s/^[^ ]+ +//"
}

#------------------------------------------------------------------------------
# Find all loop back-files under the given mountpoint (where) using losetup.
# Then find all the mountpoints associated with those loops using df.
#------------------------------------------------------------------------------
files_to_loops_to_mps() {
    local where=$1
    for loop_dev in $(losetup -ln -O name,back-file | grep -E "^[^\s]+ +$where/" | sed "s/ .*//"); do
        df -a | grep "^$loop_dev " | awk '{print $6 }'
    done
}

#------------------------------------------------------------------------------
#  If str is longer than max, truncate beginning of str three spaces less than
#  max and prepend "..." to indicate truncation has happened?
#------------------------------------------------------------------------------
my_truncate() {
    local max=$1  str=$2  len=${#2}
    if [ $len -le $max ]; then
        printf "%s\n" "$str"
        return
    fi

    local offset=$(( len - max + 3))
    printf "%s\n" "...${str:$offset:$len}"
}

lpad() {
    local width=$1  str=$2
    local len=$(echo $str | sed -r 's/\x1B\[[0-9;]+[mKC]//g' | wc -m)
    if [ $len -ge $width ]; then
        printf "%s" "$str"
        return
    fi

    printf "%$((width - len + 1))s%s" "" "$str"
}

rpad() {
    local width=$1  str=$2
    local len=$(echo $str | sed -r 's/\x1B\[[0-9;]+[mKC]//g' | wc -m)
    if [ $len -ge $width ]; then
        printf "%s" "$str"
        return
    fi

    printf "%s%$((width - len + 1))s" "$str" ""
}


#------------------------------------------------------------------------------
#
#
#------------------------------------------------------------------------------
clean_mounts() {
    local where

    for where in $(ls -d $MNT_DIR/$ISO_NAME[0-9]* $MNT_DIR/$SQ_NAME[0-9]* 2>/dev/null); do
        mountpoint -q "$where" && continue
        $SUDO rmdir "$where"
        test -d "$where" && continue
        say "Removed directory: %s" "$hi_co$where$m_co"
    done

    return


    for name in $ISO_NAME $SQ_NAME; do
        for n in $(seq 1 $MAX_DIRS); do
            what=$MNT_DIR/$name$n
            #mountpoint -q "$what" && echo "save: $what"
            mountpoint -q "$what" && continue
            test -d "$what" && $SUDO rmdir "$what"
            mp=${what##*/}
        done
    done
}

#------------------------------------------------------------------------------
#
#
#------------------------------------------------------------------------------
set_colors() {
    local scheme=${1:-high}

    local e=$(printf "\e")

    case $scheme in
        gui) rev_co=        ; nc_co=        ;;
          *) rev_co="$e[7m" ; nc_co="$e[0m" ;;
    esac

    if [ "$scheme" = 'off' -o "$scheme" == 'gui'  ]; then

         black=  ;    blue=  ;    green=  ;    cyan=  ;
           red=  ;  purple=  ;    brown=  ; lt_gray=  ;
       dk_gray=  ; lt_blue=  ; lt_green=  ; lt_cyan=  ;
        lt_red=  ; magenta=  ;   yellow=  ;   white=  ;
         brown=  ;

         inst_co=            ;  mark_co=           ;     grep_co=
         bold_co=            ;    fs_co=           ;      num_co=            ;
         date_co=            ;  head_co=           ;    quest_co=            ;
          dev_co=            ;    hi_co=           ;     quit_co=            ;
          err_co=            ;   lab_co=           ;  version_co=            ;
        fname_co=            ;     m_co=           ;     warn_co=            ;
         return
     fi

         black="$e[0;30m"   ;    blue="$e[0;34m"     ;    green="$e[0;32m"   ;    cyan="$e[0;36m"   ;
           red="$e[0;31m"   ;  purple="$e[0;35m"     ;    brown="$e[0;33m"   ; lt_gray="$e[0;37m"   ;
       dk_gray="$e[1;30m"   ; lt_blue="$e[1;34m"     ; lt_green="$e[1;32m"   ; lt_cyan="$e[1;36m"   ;
        lt_red="$e[1;31m"   ; magenta="$e[1;35m"     ;   yellow="$e[1;33m"   ;   white="$e[1;37m"   ;
         nc_co="$e[0m"      ;   brown="$e[0;33m"     ;   rev_co="$e[7m"      ;    gray="$e[37m"     ;

    case $scheme in
        high)
         inst_co=$lt_cyan    ;  mark_co=$rev_co    ;     grep_co="1;35"
         bold_co=$yellow     ;    fs_co=$lt_blue   ;      num_co=$magenta    ;
         date_co=$lt_cyan    ;  head_co=$white     ;    quest_co=$lt_green   ;
          dev_co=$white      ;    hi_co=$white     ;     quit_co=$yellow     ;
          err_co=$red        ;   lab_co=$lt_cyan   ;  version_co=$white      ;
        fname_co=$white      ;     m_co=$lt_cyan   ;     warn_co=$yellow     ; ;;

        dark)
         inst_co=$cyan       ;  mark_co=$rev_co    ;     grep_co="1;34"
         bold_co=$brown      ;    fs_co=$lt_blue   ;      num_co=$brown   ;
         date_co=$cyan       ;  head_co=$gray      ;   quest_co=$green    ;
          dev_co=$gray       ;    hi_co=$gray      ;    quit_co=$brown    ;
          err_co=$red        ;   lab_co=$cyan      ;  version_co=$gray    ;
        fname_co=$gray       ;     m_co=$cyan      ;     warn_co=$brown   ; ;;

        low)
         inst_co=$cyan       ;  mark_co=$rev_co    ;     grep_co="1;34"
         bold_co=$white      ;    fs_co=$gray      ;      num_co=$white      ;
         date_co=$gray       ;  head_co=$white     ;    quest_co=$lt_green   ;
          dev_co=$white      ;    hi_co=$white     ;     quit_co=$lt_green   ;
          err_co=$red        ;   lab_co=$gray      ;  version_co=$white      ;
        fname_co=$white      ;     m_co=$gray      ;     warn_co=$yellow     ; ;;

        low2)
         inst_co=$cyan       ;  mark_co=$rev_co    ;     grep_co="1"
         bold_co=$white      ;    fs_co=$gray      ;      num_co=$white      ;
         date_co=$gray       ;  head_co=$white     ;    quest_co=$green      ;
          dev_co=$white      ;    hi_co=$white     ;     quit_co=$green      ;
          err_co=$red        ;   lab_co=$gray      ;  version_co=$white      ;
        fname_co=$white      ;     m_co=$gray      ;     warn_co=$yellow     ; ;;

        bw)
         inst_co=$white      ;  mark_co=$rev_co    ;     grep_co="1;37"
         bold_co=$white      ;    fs_co=$gray      ;      num_co=$white      ;
         date_co=$gray       ;  head_co=$white     ;    quest_co=$white      ;
          dev_co=$white      ;    hi_co=$white     ;     quit_co=$white      ;
          err_co=$white      ;   lab_co=$lt_gray   ;  version_co=$lt_gray    ;
        fname_co=$white      ;     m_co=$gray      ;     warn_co=$white      ; ;;

        *)
            fatal "Unknown color parameter: %s" "$scheme"
    esac
}


#------------------------------------------------------------------------------
#
#
#------------------------------------------------------------------------------
read_all_cmdline_mingled() {

    : ${PARAM_CNT:=0}
    SHIFT_2=0

    while [ $# -gt 0 ]; do
        read_params "$@"
        shift $SHIFT
        SHIFT_2=$((SHIFT_2 + SHIFT))
        [ -n "$END_CMDLINE" ] && return
        while [ $# -gt 0 -a ${#1} -gt 0 -a -n "${1##-*}" ]; do
            PARAM_CNT=$((PARAM_CNT + 1))
            assign_parameter $PARAM_CNT "$1"
            shift
            SHIFT_2=$((SHIFT_2 + 1))
        done
    done
}

#------------------------------------------------------------------------------
#
#
#------------------------------------------------------------------------------
check_param_cnt() {
    local max=$1 ; shift
    [ $# -le $max ] && return
    fatal "Unexpected command line parameter(s): %s" "$*"
}

#------------------------------------------------------------------------------
#
#
#------------------------------------------------------------------------------
read_params() {
    # Most of this code is boiler-plate for parsing cmdline args
    SHIFT=0
    # These are the single-char options that can stack

    local arg val

    # Loop through the cmdline args
    while [ $# -gt 0 -a ${#1} -gt 0 -a -z "${1##-*}" ]; do
        arg=${1#-} ; shift
        SHIFT=$((SHIFT + 1))

        # Expand stacked single-char arguments
        case $arg in
            [$SHORT_STACK][$SHORT_STACK]*)
                if echo "$arg" | grep -q "^[$SHORT_STACK]\+$"; then
                    local old_cnt=$#
                    set -- $(echo $arg | sed -r 's/([a-zA-Z])/ -\1 /g') "$@"
                    SHIFT=$((SHIFT - $# + old_cnt))
                    continue
                fi;;
        esac

        # Deal with all options that take a parameter
        if takes_param "$arg"; then
            [ $# -lt 1 ] && fatal $"Expected a parameter after: %s" "-$arg"
            val=$1
            [ -n "$val" -a -z "${val##-*}" ] \
                && fatal $"Suspicious argument after %s: %s" "-$arg" "$val"
            SHIFT=$((SHIFT + 1))
            shift
        else
            case $arg in
                *=*)  val=${arg#*=} ;;
                  *)  val="???"     ;;
            esac
        fi

        eval_argument "$arg" "$val"
        [ "$END_CMDLINE" ] && return
    done
}

#------------------------------------------------------------------------------
#
#
#------------------------------------------------------------------------------
show_version() {
    local fmt="$hi_co%s$nc_co %s$num_co %s$nc_co ($date_co%s$nc_co)\n"
    printf "$fmt" "$ME" "version" "$VERSION"  "$VERSION_DATE"

    [ $# -gt 0 ]  && exit 0
}



main "$@"
