#!/bin/bash

VERSION="00.02.01"
VERSION_DATE="Sun Mar 25 02:14:12 MDT 2018"

MY_NAME=${0##*/}
ME=${ACTION:=$MY_NAME}

 MAX_DIRS=20

  MNT_DIR="/mnt/iso"
 ISO_NAME="iso"
  SQ_NAME="sq"
  SQ_FILE="antiX/linuxfs"
STAT_FILE="$MNT_DIR/status"

#------------------------------------------------------------------------------
#
#
#------------------------------------------------------------------------------
SUDO="sudo"
[ $UID -eq 0 ] && SUDO=

iso_mount_usage() {
    local fname=$MNT_DIR/${ISO_NAME}1
    cat <<Usage
${bold_co}Usage:${m_co} $ME [options] /path/to/file.iso${nc_co}
    Mount the iso file specified at a directory like $fname.  If
    it is an MX or antiX iso then also mount the /$SQ_FILE file
    as a squashfs file.

    Also add an entry in the status file like /mnt/iso1@<name> where
    <name> is the path to the mounted file.

Usage
    opt_usage
}

#------------------------------------------------------------------------------
#
#
#------------------------------------------------------------------------------
sq_mount_usage() {
    local fname=$MNT_DIR/${SQ_NAME}1
    cat <<Usage
${bold_co}Usage:${m_co} $ME [options] /path/to/squashfs-file${nc_co}
    Mount the squashfs file specified at a directory like $fname/

    Also add an entry in the status file like /mnt/sq1@<name> where
    <name> is the path to the mounted file.
Usage
    opt_usage
}

#------------------------------------------------------------------------------
#
#
#------------------------------------------------------------------------------
iso_umount_usage() {
    local fname=$MNT_DIR/${ISO_NAME}N
    cat <<Usage
${bold_co}Usage:${m_co} $ME [options] [$fname|'all']${nc_co}
    Umount the most recently mounted iso file.  If a mountpoint is
    given then unmount that mountpoint instead.  In both cases we also
    remove then entry from the status file.

    If 'all' is given then unmount all of our mounts and all entries
    from the status file.
Usage
    opt_usage
}

#------------------------------------------------------------------------------
#
#
#------------------------------------------------------------------------------
sq_umount_usage() {
    local fname=$MNT_DIR/${SQ_NAME}N
    cat <<Usage
${bold_co}Usage:${m_co} $ME [options] [$fname|'all']${nc_co}
    Umount the most recently mounted squashfs file.  If a mountpoint is
    given then unmount that mountpoint instead.  In both cases we also
    delete the mountpoint directory and the $fname@<name> file.

    If 'all' is given then unmount all of our mounts and all entries
    from the status file.
Usage
    opt_usage
}

#------------------------------------------------------------------------------
#
#
#------------------------------------------------------------------------------
clean_usage() {
    cat <<Usage
${bold_co}Usage:${m_co} $ME [options]${nc_co}
    Clean up leftover mountpoint directories and @ files.
Usage
    opt_usage
}

#------------------------------------------------------------------------------
#
#
#------------------------------------------------------------------------------
show_usage() {
    cat <<Usage
${bold_co}Usage:${m_co} $ME [options]${nc_co}
    Show the currently mounted iso and squashfs files
Usage
    opt_usage
}

opt_usage() {
    [ "$DONT_SHOW_OPTS" ] && return
    cat <<Usage

${bold_co}Options:$nc_co
    $m_co-c --color=<xxx>  $nc_co set color scheme to off|low|low2|bw|dark|high
    $m_co-h --help         $nc_co show this usage
    $m_co-q --quiet        $nc_co only show mountpoints
    $m_co-q --quiet        $nc_co don't show mountpoint(s)
    $m_co-s --silent       $nc_co don't print anything except errors
    $m_co-v --version      $nc_co show version number and exit
    $m_co-V --verbose      $nc_co be more verbose
Usage
}

#------------------------------------------------------------------------------
#
#
#------------------------------------------------------------------------------
usage() {
    case $ME in
             isomount)   ;;
              sqmount)   ;;
            isoumount)   ;;
             squmount)   ;;
       clean-isomount)   ;;
        show-isomount)   ;;
                    *) fatal "Unknown program name %s" $ME ;;
    esac

    show_version
    echo

    if [ "$1" == 'all' ]; then
        DONT_SHOW_OPTS=true
        iso_mount_usage    ; echo
        sq_mount_usage     ; echo
        iso_umount_usage   ; echo
        sq_umount_usage    ; echo
        clean_usage        ; echo
        show_usage         ; echo

        DONT_SHOW_OPTS=
        opt_usage
        exit 0
    fi

    case $ME in
             isomount) iso_mount_usage     ;;
              sqmount) sq_mount_usage      ;;
            isoumount) iso_umount_usage    ;;
             squmount) sq_umount_usage     ;;
       clean-isomount) clean_usage         ;;
        show-isomount) show_usage          ;;
                    *) fatal "Unknown program name %s" $ME ;;
    esac


    exit 0
}

#------------------------------------------------------------------------------
#
#
#------------------------------------------------------------------------------
takes_param() {
    case $1 in
        -color|c) return 0 ;;
               *) return 1 ;;
    esac
}

#------------------------------------------------------------------------------
#
#
#------------------------------------------------------------------------------
assign_parameter() {
    local cnt=$1 param=$2
    CMD_CMDS="$CMD_CMDS${CMD_CMDS:+ }$param"
}

#------------------------------------------------------------------------------
#
#
#------------------------------------------------------------------------------
eval_argument() {
    local arg=$1  val=$2
    case $arg in
         -color|c)  COLOR_SCHEME=$val   ;;
         -color=*)  COLOR_SCHEME=$val   ;;
          -help|h)  DO_HELP=true        ;;
         -quiet|q)  ONLY_MPS=true       ;;
         -Quiet|Q)  NO_MPS=true         ;;
        -silent|s)  BE_SILENT=true      ;;
       -version|v)  SHOW_VERSION=true   ;;
       -verbose|V)  BE_VERBOSE=true     ;;
                *)  fatal "Unknown parameter %s" "-$arg"  ;;
    esac
}

#------------------------------------------------------------------------------
#
#
#------------------------------------------------------------------------------
main() {
    local SHIFT SHIFT_2  SHORT_STACK="hQqsVv"
    local NO_MPS ONLY_MPS  BE_SILENT BE_VERBOSE  PARAM_CNT

    set_colors
    read_all_cmdline_mingled "$@"
    shift $SHIFT_2
    set_colors $COLOR_SCHEME

    local max_param=0  min_param=0
    case $ME in
          isomount|sqmount)  max_param=1  ; min_param=1 ;;
        isoumount|squmount)  max_param=1                ;;
    esac

    [ "$DO_HELP" ] && usage "$CMD_CMDS"
    [ "$SHOW_VERSION" ] && show_version 'exit'

    [ $PARAM_CNT -lt $min_param ] && usage
    [ $PARAM_CNT -gt $max_param ] && fatal "Too many command line parameters"
    case $ME in
             isomount)  iso_mount    "$CMD_CMDS"       ;;
              sqmount)  sq_mount     "$CMD_CMDS"       ;;
            isoumount)  iso_umount   "$CMD_CMDS"       ;;
             squmount)  sq_umount    "$CMD_CMDS"       ;;
       clean-isomount)  clean_mounts                   ;;
        show-isomount)  show_mounts ; exit 0           ;;
                    *)  fatal "Unknown program name %s" $ME ;;
    esac

    [ -z "$BE_SILENT$NO_MPS" ] && show_mounts
    exit 0
}

#------------------------------------------------------------------------------
#
#
#------------------------------------------------------------------------------
iso_mount() {
    local what=$1
    any_mount "$ISO_NAME" "$what" -o loop,user,ro,exec -t iso9660

}

#------------------------------------------------------------------------------
#
#
#------------------------------------------------------------------------------
sq_mount() {
    local what=$1
    any_mount "$SQ_NAME" "$what"  -o loop,user,ro,exec -t squashfs
}

#------------------------------------------------------------------------------
#
#
#------------------------------------------------------------------------------
iso_umount() {
    local name=$ISO_NAME  where=$1
    any_umount "$name" $where
}

#------------------------------------------------------------------------------
#
#
#------------------------------------------------------------------------------
sq_umount() {
    local name=$SQ_NAME  Ewhere=$1
    any_umount "$name" $where
}


#------------------------------------------------------------------------------
#
#
#------------------------------------------------------------------------------
any_mount() {
    verbose "any_mount(%s)" "$bold_co$*$quest_co"

    local name=$1  what=$2    where  n; shift 2
    [ -z "$what" ]  && fatal "Need to say what we should %s"   "$ME"

    test -e "$what" || fatal "Can not find file: %s"           "$what"
    test -f "$what" || fatal "%s does not appear to be a file" "$what"

    if ! mountpoint -q "$MNT_DIR"; then
        $SUDO mkdir -p "$MNT_DIR"
        $SUDO mount -t tmpfs -o size=1m tmpfs "$MNT_DIR"
        mountpoint -q "$MNT_DIR" || fatal "Could not mount %s as %s"  "$MNT_DIR" 'tmpfs'
        $SUDO touch $STAT_FILE
    fi
    for n in $(seq 1 $MAX_DIRS); do
        where=$MNT_DIR/$name$n
        mountpoint -q "$where" || break
    done
    mountpoint -q  "$where" && fatal "Mount point %s and below are already taken" "$where"

    local mp=${where##*/}

    $SUDO mkdir -p "$where" || fatal "Could not create the directory %s" "$where"
    $SUDO mount "$@" "$what" "$where"

    if ! mountpoint -q "$where"; then
        $SUDO rmdir "$where"
        fatal "Was unable to mount %s" "$* $what $where"
    fi

    say "Mounted %s at %s" "$hi_co$what$m_co" "$hi_co$where$m_co"

    $SUDO touch $STAT_FILE
    $SUDO sed -i "/^$mp@/d" $STAT_FILE
    echo "$mp@$what" | $SUDO tee -a $STAT_FILE > /dev/null

    local sq_file=$where/$SQ_FILE
    [ "$name" == "$ISO_NAME" -a -e "$sq_file" ] || return
    sq_mount "$sq_file"
}

#------------------------------------------------------------------------------
#
#
#------------------------------------------------------------------------------
any_umount() {
    verbose "any_umount(%s)" "$bold_co$*$quest_co"
    local name=$1  where=$2
    if [ "$where" == 'all' ]; then
        local mp i is_done
        for i in $(seq 1 1); do
            is_done=true
            for mp in $(df -a | awk '{print $6 }' | grep "^$MNT_DIR/" | tac); do
                mountpoint -q $mp || continue
                $SUDO umount $mp

                if mountpoint -q $mp; then
                    is_done=
                else
                    say "Unmounted %s" "$hi_co$mp$m_co"
	                $SUDO sed -i "/^${mp##*/}@/d" $STAT_FILE
                fi
            done
            [ "$is_done" ] && break
        done
        show_mounts
        return

    elif [ -n "$where" ]; then
        mountpoint -q "$where" || fatal "%s is not a mountpoint" "$where"
        name=${where##*/}
        name=${name%%[0-9]*}
        case $name in
            $ISO_NAME|$SQ_NAME) ;;
            *) fatal "Unrecognized name %s" "$name" ;;
        esac

    else
        local n
        for n in $(seq $MAX_DIRS -1 1); do
            where=$MNT_DIR/$name$n
            mountpoint -q "$where" && break
        done
        mountpoint -q "$where" || fatal "No %s mountpoints found" "$name"

    fi
    local sq_file=$where/$SQ_FILE

    if [ "$name" == "$ISO_NAME" -a -e "$sq_file" ]; then

        local pointer sq_mp
        for pointer in $(grep -E "^sq[0-9]+@$sq_file$" $STAT_FILE 2>/dev/null); do
            sq_mp=$MNT_DIR/${pointer%%@*}
            mountpoint -q "$sq_mp" && do_umount "$sq_mp"
        done
    fi

    do_umount "$where"
}

#------------------------------------------------------------------------------
#
#
#------------------------------------------------------------------------------
do_umount() {
    verbose "do_umount(%s)" "$bold_co$*$quest_co"
    local where=$1
	$SUDO umount  "$where"
	mountpoint -q "$where" && fatal "Failed to umount %s" "$where"
	$SUDO rmdir   "$where" || fatal "Failed to remove %s directory" "$where"

    local mp=${where##*/}
    local what=$(sed "s/$mp@//" $STAT_FILE)
    if [ -z "$what" ]; then
        say "Unmounted %s (%s)" "$hi_co$where$m_co" "$hi_co$what$m_co"
    else
        say "Unmounted %s" "$hi_co$where$m_co"
    fi

    local mp=${where##*/}
	$SUDO sed -i "/^$mp@/d" $STAT_FILE
}

#------------------------------------------------------------------------------
#
#
#------------------------------------------------------------------------------
fatal() {
    local fmt=$1 ; shift
    printf "$ME: $warn_co$fmt$nc_co\n" "$@" >&2
    exit 2
}

#------------------------------------------------------------------------------
#
#
#------------------------------------------------------------------------------
say() {
    [ "$BE_SILENT$ONLY_MPS" ] && return
    local fmt=$1 ; shift
    printf "$ME: $m_co$fmt$nc_co\n" "$@"
}

#------------------------------------------------------------------------------
#
#
#------------------------------------------------------------------------------
verbose() {
    [ "$BE_VERBOSE" ] || return
    local fmt=$1 ; shift
    printf "$ME: $quest_co$fmt$nc_co\n" "$@"
}

#------------------------------------------------------------------------------
# Show the mount points we have created together with the file that is mounted
# and type and size. We go through the list of mount points twice.  The first
# time we get the maximum width so everything lines up nice and neat.
#
# I should truncate the file names if we don't fit the screen and I should
# add colors.
#------------------------------------------------------------------------------
show_mounts() {
    local data=$(df -ahT | grep -E " $MNT_DIR/($ISO_NAME|$SQ_NAME)[0-9]")
    [ -z "$data" ] && return

    local w_file=$(sed "s/^[^@]*@//" $STAT_FILE | awk '{print length}' | sort -r | head -n1)

    local dev type size used avail percent mp file
    local w_type=0 w_size=0 w_mp=0
    while read dev type size used avail percent mp; do
        [ ${#dev} -gt 0   ] || continue
        [ $w_type -lt ${#type} ] && w_type=${#type}
        [ $w_size -lt ${#size} ] && w_size=${#size}
        [ $w_mp -lt ${#mp} ] && w_mp=${#mp}
    done <<Show_Mounts
$(echo "$data")
Show_Mounts

    echo
    local hfmt="$head_co%-${w_file}s  %-${w_type}s  %${w_size}s  %-${w_mp}s$nc_co\n"
    printf "$hfmt" 'File' 'Type' 'Size' 'Mount Point'

    local fmt="$dev_co%-${w_file}s  $warn_co%-${w_type}s  $num_co%${w_size}s  $m_co%-${w_mp}s$nc_co\n"

    while read dev type size used avail percent mp; do
        file=$(sed -n "s|${mp##*/}@||p" $STAT_FILE | head -n1)
        [ ${#dev} -gt 0   ] || continue
        printf "$fmt" "$file" "$type" "$size" "$mp"
    done <<Show_Mounts
$(echo "$data")
Show_Mounts
    [ -n "$BE_VERBOSE" -a -e "$STAT_FILE" ] || return
    echo
    cat $STAT_FILE
}

#------------------------------------------------------------------------------
#
#
#------------------------------------------------------------------------------
clean_mounts() {
    local name what n mp
    for name in $ISO_NAME $SQ_NAME; do
        for n in $(seq 1 $MAX_DIRS); do
            what=$MNT_DIR/$name$n
            mountpoint -q "$what" && echo "save: $what"
            mountpoint -q "$what" && continue
            test -d "$what" && $SUDO rmdir "$what"
            mp=${what##*/}
            test -e $STAT_FILE && $SUDO sed -i "/^$mp@/d" $STAT_FILE
        done
    done
}

#------------------------------------------------------------------------------
#
#
#------------------------------------------------------------------------------
set_colors() {
    local color=${1:-high}

    local e=$(printf "\e")

    rev_co="$e[7m" ; nc_co="$e[0m"

    if [ "$color" = 'off' ]; then

         black=  ;    blue=  ;    green=  ;    cyan=  ;
           red=  ;  purple=  ;    brown=  ; lt_gray=  ;
       dk_gray=  ; lt_blue=  ; lt_green=  ; lt_cyan=  ;
        lt_red=  ; magenta=  ;   yellow=  ;   white=  ;
         brown=  ;

         inst_co=            ;  mark_co=           ;     grep_co=
         bold_co=            ;    fs_co=           ;      num_co=            ;
         date_co=            ;  head_co=           ;    quest_co=            ;
          dev_co=            ;    hi_co=           ;     quit_co=            ;
          err_co=            ;   lab_co=           ;  version_co=            ;
        fname_co=            ;     m_co=           ;     warn_co=            ;
         return
     fi

         black="$e[30m"   ;    blue="$e[34m"   ;    green="$e[32m"   ;    cyan="$e[36m"   ;
           red="$e[31m"   ;  purple="$e[35m"   ;    brown="$e[33m"   ; lt_gray="$e[37m"   ;
       dk_gray="$e[1;30m" ; lt_blue="$e[1;34m" ; lt_green="$e[1;32m" ; lt_cyan="$e[1;36m" ;
        lt_red="$e[1;31m" ; magenta="$e[1;35m" ;   yellow="$e[1;33m" ;   white="$e[1;37m" ;
         nc_co="$e[0m"    ;   brown="$e[33m"   ;   rev_co="$e[7m"    ;    gray="$e[37m"

    case $color in
        high)
         inst_co=$lt_cyan    ;  mark_co=$rev_co    ;     grep_co="1;35"
         bold_co=$yellow     ;    fs_co=$lt_blue   ;      num_co=$magenta    ;
         date_co=$lt_cyan    ;  head_co=$white     ;    quest_co=$lt_green   ;
          dev_co=$white      ;    hi_co=$white     ;     quit_co=$yellow     ;
          err_co=$red        ;   lab_co=$lt_cyan   ;  version_co=$white      ;
        fname_co=$white      ;     m_co=$lt_cyan   ;     warn_co=$yellow     ; ;;

        dark)
         inst_co=$cyan       ;  mark_co=$rev_co    ;     grep_co="1;34"
         bold_co=$brown      ;    fs_co=$lt_blue   ;      num_co=$brown   ;
         date_co=$cyan       ;  head_co=$gray      ;   quest_co=$green    ;
          dev_co=$gray       ;    hi_co=$gray      ;    quit_co=$brown    ;
          err_co=$red        ;   lab_co=$cyan      ;  version_co=$gray    ;
        fname_co=$gray       ;     m_co=$cyan      ;     warn_co=$brown   ; ;;

        low)
         inst_co=$cyan       ;  mark_co=$rev_co    ;     grep_co="1;34"
         bold_co=$white      ;    fs_co=$gray      ;      num_co=$white      ;
         date_co=$gray       ;  head_co=$white     ;    quest_co=$lt_green   ;
          dev_co=$white      ;    hi_co=$white     ;     quit_co=$lt_green   ;
          err_co=$red        ;   lab_co=$gray      ;  version_co=$white      ;
        fname_co=$white      ;     m_co=$gray      ;     warn_co=$yellow     ; ;;

        low2)
         inst_co=$cyan       ;  mark_co=$rev_co    ;     grep_co="1"
         bold_co=$white      ;    fs_co=$gray      ;      num_co=$white      ;
         date_co=$gray       ;  head_co=$white     ;    quest_co=$green      ;
          dev_co=$white      ;    hi_co=$white     ;     quit_co=$green      ;
          err_co=$red        ;   lab_co=$gray      ;  version_co=$white      ;
        fname_co=$white      ;     m_co=$gray      ;     warn_co=$yellow     ; ;;

        bw)
         inst_co=$white      ;  mark_co=$rev_co    ;     grep_co="1;37"
         bold_co=$white      ;    fs_co=$gray      ;      num_co=$white      ;
         date_co=$gray       ;  head_co=$white     ;    quest_co=$white      ;
          dev_co=$white      ;    hi_co=$white     ;     quit_co=$white      ;
          err_co=$white      ;   lab_co=$lt_gray   ;  version_co=$lt_gray    ;
        fname_co=$white      ;     m_co=$gray      ;     warn_co=$white      ; ;;

        *)
            fatal "Unknown color parameter: %s" "$color"
    esac
}


#------------------------------------------------------------------------------
#
#
#------------------------------------------------------------------------------
read_all_cmdline_mingled() {

    : ${PARAM_CNT:=0}
    SHIFT_2=0

    while [ $# -gt 0 ]; do
        read_params "$@"
        shift $SHIFT
        SHIFT_2=$((SHIFT_2 + SHIFT))
        [ -n "$END_CMDLINE" ] && return
        while [ $# -gt 0 -a ${#1} -gt 0 -a -n "${1##-*}" ]; do
            PARAM_CNT=$((PARAM_CNT + 1))
            assign_parameter $PARAM_CNT "$1"
            shift
            SHIFT_2=$((SHIFT_2 + 1))
        done
    done
}

#------------------------------------------------------------------------------
#
#
#------------------------------------------------------------------------------
check_param_cnt() {
    local max=$1 ; shift
    [ $# -le $max ] && return
    fatal "Unexpected command line parameter(s): %s" "$*"
}

#------------------------------------------------------------------------------
#
#
#------------------------------------------------------------------------------
read_params() {
    # Most of this code is boiler-plate for parsing cmdline args
    SHIFT=0
    # These are the single-char options that can stack

    local arg val

    # Loop through the cmdline args
    while [ $# -gt 0 -a ${#1} -gt 0 -a -z "${1##-*}" ]; do
        arg=${1#-} ; shift
        SHIFT=$((SHIFT + 1))

        # Expand stacked single-char arguments
        case $arg in
            [$SHORT_STACK][$SHORT_STACK]*)
                if echo "$arg" | grep -q "^[$SHORT_STACK]\+$"; then
                    local old_cnt=$#
                    set -- $(echo $arg | sed -r 's/([a-zA-Z])/ -\1 /g') "$@"
                    SHIFT=$((SHIFT - $# + old_cnt))
                    continue
                fi;;
        esac

        # Deal with all options that take a parameter
        if takes_param "$arg"; then
            [ $# -lt 1 ] && fatal $"Expected a parameter after: %s" "-$arg"
            val=$1
            [ -n "$val" -a -z "${val##-*}" ] \
                && fatal $"Suspicious argument after %s: %s" "-$arg" "$val"
            SHIFT=$((SHIFT + 1))
            shift
        else
            case $arg in
                *=*)  val=${arg#*=} ;;
                  *)  val="???"     ;;
            esac
        fi

        eval_argument "$arg" "$val"
        [ "$END_CMDLINE" ] && return
    done
}

#------------------------------------------------------------------------------
#
#
#------------------------------------------------------------------------------
show_version() {
    local fmt="%s %s$num_co %s$nc_co ($date_co%s$nc_co)\n"
    printf "$fmt" "$ME" "version" "$VERSION"  "$VERSION_DATE"

    [ $# -gt 0 ]  && exit 0
}



main "$@"
