#!/bin/bash


#------------------------------------------------------------------------------
# Program: dfh
#
# A fancy version of dfh.
#------------------------------------------------------------------------------

VERSION="00.04.03"
VERSION_DATE="Thu Mar 29 23:05:41 MDT 2018"

ME=${0##*/}

HEADER_TYPE="rev2"
MIN_DEV_WIDTH=12

EXCLUDE_FS_TYPES="tmpfs devtmpfs rootfs proc devpts sysfs mqueue securityfs debugfs
                 fusectl pstore cgroup binfmt_misc hugetlbfs"

         YAD="/usr/bin/yad"
   YAD_IMAGE="/usr/local/lib/antiX/antiX-logo.png"
YAD_STD_OPTS="--center --width=900 --height=600 --button=gtk-ok:0 "
test -r $YAD_IMAGE && YAD_STD_OPTS="$YAD_STD_OPTS -image=$YAD_IMAGE"

SCREEN_WIDTH=$(stty size | cut -d" " -f2)

usage() {

    show_version
    printf "\n"

cat << Usage
${bold_co}Usage:${m_co} $ME [options]${nc_co}

List "interesting" mounted file systems for humans.  Display in color and
show the back-files for loop devices.

${bold_co}Options:$nc_co
    $m_co-c --color=<xxx>    $nc_co set color scheme to off|low|low2|bw|dark|high
    $m_co-g --gui          $nc_co show output in a yad window
    $m_co-h --help           $nc_co show this usage
    $m_co-H --header=<type>  $nc_co change header color: norm, rev1, rev2, rev3
                                             (n,      r1,   r2,   r3)
    $m_co-v --version        $nc_co show version number and exit
    $m_co-x, --exclude-type=<xxx> $nc_co list of more file types to exclude
                         (comma separated)
Usage
    exit 0
}

#------------------------------------------------------------------------------
#
#
#------------------------------------------------------------------------------
takes_param() {
    case $1 in
            -color|c) return 0 ;;
           -header|H) return 0 ;;
     -exclude-type|x) return 0 ;;
                   *) return 1 ;;
    esac
}

#------------------------------------------------------------------------------
#
#
#------------------------------------------------------------------------------
assign_parameter() {
    local cnt=$1 param=$2
    CMD_CMDS="$CMD_CMDS${CMD_CMDS:+ }$param"
}

#------------------------------------------------------------------------------
#
#
#------------------------------------------------------------------------------
eval_argument() {
    local arg=$1  val=$2
    case $arg in
             -color|c)  COLOR_SCHEME=$val   ;;
             -color=*)  COLOR_SCHEME=$val   ;;
               -gui|g)  GUI_MODE=true       ;;
            -header|H)  HEADER_TYPE=$val    ;;
            -header=*)  HEADER_TYPE=$val    ;;
              -help|h)  usage               ;;
           -version|v)  SHOW_VERSION=true   ;;
      -exclude-type|x)  USER_EXCLUDES="$USER_EXCLUDES ${val//,/ }" ;;
                    *)  fatal "Unknown parameter %s" "-$arg"       ;;
    esac
}

#------------------------------------------------------------------------------
#
#
#------------------------------------------------------------------------------
main() {
    local SHIFT SHIFT_2  SHORT_STACK="cHhvx"
    local PARAM_CNT
    set_colors
    read_all_cmdline_mingled "$@"
    shift $SHIFT_2
    [ -z "$SCREEN_WIDTH"  -o "$SCREEN_WIDTH" = 0 ] && GUI_MODE=true

    if [ "$GUI_MODE" ]; then
        set_colors gui
    else
        set_colors $COLOR_SCHEME
    fi

    [ "$DO_HELP" ] && usage "$CMD_CMDS"
    [ "$SHOW_VERSION" ] && show_version 'exit'
    case $HEADER_TYPE in
        norm|rev[123]|n|r[123]) ;;
                    *) fatal "Unknown header type: %s" "$HEADER_TYPE"
    esac

    [ "$BE_VERBOSE" ] && show_version
    do_dfh

    exit 0
}

#------------------------------------------------------------------------------
# This is the main event
#------------------------------------------------------------------------------
do_dfh() {
    local exclude_list=$(echo $EXCLUDE_FS_TYPES $USER_EXCLUDES | sed -r "s/\s+/ -x /g")
    local data=$(df -ahT -x $exclude_list | tail -n+2)

    #echo "$data"
    #echo

    local lab_dev="File/Device"
    local lab_type="Type"
    local lab_size="Size"
    local lab_used="Used"
    local lab_avail="Avail"
    local lab_cent="Use%"
    local lab_mp="Mounted on"

    [ "$GUI_MODE" ] && show_mounts_gui "$data"

    local w_dev=$(losetup --list --noheadings -O back-file |  awk '{print length}' | sort -r  | head -n1)
    [ ${w_dev:-0} -lt ${#lab_dev} ] && w_dev=${#lab_dev}

    # Find max width of all the fields
    local dev type size used avail cent mp
    local w_type=${#lab_type}  w_size=${#lab_size} w_used=${#lab_used} w_avail=${#lab_avail} w_cent=${#lab_cent} w_mp=${#lab_mp}
    while read dev type size used avail cent mp; do
        [ ${#dev}  -gt 0         ] || continue
        [ $w_dev   -lt ${#dev}   ] && w_dev=${#dev}
        [ $w_type  -lt ${#type}  ] && w_type=${#type}
        [ $w_size  -lt ${#size}  ] && w_size=${#size}
        [ $w_used  -lt ${#used}  ] && w_used=${#used}
        [ $w_avail -lt ${#avail} ] && w_avail=${#avail}
        [ $w_cent  -lt ${#cent}  ] && w_cent=${#cent}
        [ $w_mp    -lt ${#mp}    ] && w_mp=${#mp}
    done <<Dfh_Loop1
$(echo "$data" | tail -n+2)
Dfh_Loop1


    local truncate=$((w_dev + w_type + w_size + w_used + w_avail + w_cent + w_mp - SCREEN_WIDTH + 12))
    if [ $truncate -gt 0 ]; then
        w_dev=$((w_dev - truncate))
        [ $w_dev -lt $MIN_DEV_WIDTH ] && fatal "The screen appears to be way too narrow!"
    fi

    local h_co=$head_co$rev_co hfmt hfmt1 hfmt1
    local h1=
    case $HEADER_TYPE in norm|n) h_co=$head_co  ;; esac

    hfmt1="$h_co%-${w_dev}s  %-${w_type}s  %${w_size}s  %${w_used}s  %${w_avail}s  %${w_cent}s  %-${w_mp}s$nc_co\n"
    hfmt2="$h_co%-${w_dev}s$nc_co  $h_co%-${w_type}s$nc_co  $h_co%${w_size}s$nc_co  $h_co%${w_used}s$nc_co  $h_co%${w_avail}s$nc_co  $h_co%${w_cent}s$nc_co  $h_co%-${w_mp}s$nc_co\n"

    hfmt=$hfmt1
    case $HEADER_TYPE in
          rev2|r2) hfmt=$hfmt2 ;;
    esac

    case $HEADER_TYPE in
        rev3|r3)
            printf "$h_co%s  "   "$(rpad $w_dev   "$lab_dev$nc_co"   )"
            printf "$h_co%s  "   "$(rpad $w_type  "$lab_type$nc_co"  )"
            printf "$h_co%s  "   "$(lpad $w_size  "$lab_size$nc_co"  )"
            printf "$h_co%s  "   "$(lpad $w_used  "$lab_used$nc_co"  )"
            printf "$h_co%s  "   "$(lpad $w_avail "$lab_avail$nc_co" )"
            printf "$h_co%s  "   "$(rpad $w_cent  "$lab_cent$nc_co"  )"
            printf "$h_co%s\n"   "$lab_mp$nc_co"  ;;
        *)
            printf "$hfmt" "$lab_dev"  "$lab_type" "$lab_size" "$lab_used" "$lab_avail" "$lab_cent" "$lab_mp" ;;
    esac

    while read dev type size used avail cent mp; do
        [ ${#dev} -gt 0   ] || continue
        local type_co=$warn_co
        if echo "$dev" | grep -q "^/dev/loop[0-9]" ; then
            used=-
            avail=-
            cent=-
            local file=$(loop_to_file $dev)
            [ -n "$file" ] && dev=$file

            case $type in
                  iso9660) type_co=$purple    ;;
                 squashfs) type_co=$quest_co ;;
                     udf)  type_co=$quit_co  ;;
            esac
        fi
        dev=$(my_truncate "$w_dev" "$dev")

        local fmt="$m_co%-${w_dev}s  $type_co%-${w_type}s  $num_co%${w_size}s$nc_co  %${w_used}s  %${w_avail}s  %${w_cent}s  $m_co%-s$nc_co\n"
        printf "$fmt" "$dev" "$type" "$size" "$used" "$avail" "$cent" "$mp"
    done <<Dfh_Loop2
$(echo "$data" | tail -n+2)
Dfh_Loop2
}
#------------------------------------------------------------------------------
#
#
#------------------------------------------------------------------------------
show_mounts_gui() {
    local data=$1
    device_info "$data" | $YAD $YAD_STD_OPTS \
        --title "$ME"         \
        --text "$GUI_TEXT"    \
        --list                \
        --column="$lab_dev"   \
        --column="$lab_type"  \
        --column="$lab_size"  \
        --column="$lab_used"  \
        --column="$lab_avail" \
        --column="$lab_cent"  \
        --column="$lab_mp"
        #2>/dev/null

    exit 0
}

#------------------------------------------------------------------------------
#
#
#------------------------------------------------------------------------------
device_info() {
    local data="$1" file

    while read dev type size used avail cent mp; do
        [ ${#dev} -gt 0   ] || continue
        file=$(loop_to_file $dev)
        [ -n "$file" ] && dev=$file

        echo -e "$dev\n$type\n$size\n$used\n$avail\n$cent\n$mp"
    done <<Device_Info
$(echo "$data")
Device_Info
}

#------------------------------------------------------------------------------
#
#
#------------------------------------------------------------------------------
my_truncate() {
    local max=$1  str=$2  len=${#2}
    if [ $len -le $max ]; then
        printf "%s\n" "$str"
        return
    fi

    local offset=$(( len - max + 3))
    printf "%s\n" "...${str:$offset:$len}"
}

lpad() {
    local width=$1  str=$2
    local len=$(echo $str | sed -r 's/\x1B\[[0-9;]+[mKC]//g' | wc -m)
    if [ $len -ge $width ]; then
        printf "%s" "$str"
        return
    fi

    printf "%$((width - len + 1))s%s" "" "$str"
}

rpad() {
    local width=$1  str=$2
    local len=$(echo $str | sed -r 's/\x1B\[[0-9;]+[mKC]//g' | wc -m)
    if [ $len -ge $width ]; then
        printf "%s" "$str"
        return
    fi

    printf "%s%$((width - len + 1))s" "$str" ""
}

#------------------------------------------------------------------------------
# Get the filename associated with the given loopback device
#------------------------------------------------------------------------------
loop_to_file() {
    local dev=$1
    losetup -nl -O name,back-file | grep "^$dev " | sed -r "s/^[^ ]+ +//"
}

#------------------------------------------------------------------------------
#
#
#------------------------------------------------------------------------------
fatal() {
    local fmt=$1 ; shift
    if [ -z "$BE_SILENT" ]; then
        [ "$GUI_MODE" ] && error_box "$(printf "$fmt%s" "$@" '\n')"
        printf "$ME: $warn_co$fmt$nc_co\n" "$@" >&2
    fi
    exit 2
}

#------------------------------------------------------------------------------
#
#
#------------------------------------------------------------------------------
say() {
    local fmt=$1 ; shift

    [ "$ONLY_MPS" ] && return
    [ "$GUI_MODE" ] && GUI_TEXT="$GUI_TEXT$(printf "$fmt%s"  "$@" '\n')"
    printf "$ME: $m_co$fmt$nc_co\n" "$@"
}

#------------------------------------------------------------------------------
#
#
#------------------------------------------------------------------------------
verbose() {
    [ "$BE_VERBOSE" ] || return
    local fmt=$1 ; shift
    printf "$ME: $quest_co$fmt$nc_co\n" "$@"
}

#------------------------------------------------------------------------------
#
#
#------------------------------------------------------------------------------
error_box() {
    local text=$(printf "\n\n%s\n\n" "$*")
    $YAD $YAD_ERR_OPTS --title "$ME"  --text "$text"
    exit 2
}

#------------------------------------------------------------------------------
#
#
#------------------------------------------------------------------------------
set_colors() {
    local scheme=${1:-high}

    local e=$(printf "\e")

    case $scheme in
        gui) rev_co=        ; nc_co=        ;;
          *) rev_co="$e[7m" ; nc_co="$e[0m" ;;
    esac

    if [ "$scheme" = 'off' -o "$scheme" == 'gui'  ]; then

         black=  ;    blue=  ;    green=  ;    cyan=  ;
           red=  ;  purple=  ;    brown=  ; lt_gray=  ;
       dk_gray=  ; lt_blue=  ; lt_green=  ; lt_cyan=  ;
        lt_red=  ; magenta=  ;   yellow=  ;   white=  ;
         brown=  ;

         inst_co=            ;  mark_co=           ;     grep_co=
         bold_co=            ;    fs_co=           ;      num_co=            ;
         date_co=            ;  head_co=           ;    quest_co=            ;
          dev_co=            ;    hi_co=           ;     quit_co=            ;
          err_co=            ;   lab_co=           ;  version_co=            ;
        fname_co=            ;     m_co=           ;     warn_co=            ;
         return
     fi

         black="$e[0;30m"   ;    blue="$e[0;34m"     ;    green="$e[0;32m"   ;    cyan="$e[0;36m"   ;
           red="$e[0;31m"   ;  purple="$e[0;35m"     ;    brown="$e[0;33m"   ; lt_gray="$e[0;37m"   ;
       dk_gray="$e[1;30m"   ; lt_blue="$e[1;34m"     ; lt_green="$e[1;32m"   ; lt_cyan="$e[1;36m"   ;
        lt_red="$e[1;31m"   ; magenta="$e[1;35m"     ;   yellow="$e[1;33m"   ;   white="$e[1;37m"   ;
         nc_co="$e[0m"      ;   brown="$e[0;33m"     ;   rev_co="$e[7m"      ;    gray="$e[37m"     ;

    case $scheme in
        high)
         inst_co=$lt_cyan    ;  mark_co=$rev_co    ;     grep_co="1;35"
         bold_co=$yellow     ;    fs_co=$lt_blue   ;      num_co=$magenta    ;
         date_co=$lt_cyan    ;  head_co=$white     ;    quest_co=$lt_green   ;
          dev_co=$white      ;    hi_co=$white     ;     quit_co=$yellow     ;
          err_co=$red        ;   lab_co=$lt_cyan   ;  version_co=$white      ;
        fname_co=$white      ;     m_co=$lt_cyan   ;     warn_co=$yellow     ; ;;

        dark)
         inst_co=$cyan       ;  mark_co=$rev_co    ;     grep_co="1;34"
         bold_co=$brown      ;    fs_co=$lt_blue   ;      num_co=$brown   ;
         date_co=$cyan       ;  head_co=$gray      ;   quest_co=$green    ;
          dev_co=$gray       ;    hi_co=$gray      ;    quit_co=$brown    ;
          err_co=$red        ;   lab_co=$cyan      ;  version_co=$gray    ;
        fname_co=$gray       ;     m_co=$cyan      ;     warn_co=$brown   ; ;;

        low)
         inst_co=$cyan       ;  mark_co=$rev_co    ;     grep_co="1;34"
         bold_co=$white      ;    fs_co=$gray      ;      num_co=$white      ;
         date_co=$gray       ;  head_co=$white     ;    quest_co=$lt_green   ;
          dev_co=$white      ;    hi_co=$white     ;     quit_co=$lt_green   ;
          err_co=$red        ;   lab_co=$gray      ;  version_co=$white      ;
        fname_co=$white      ;     m_co=$gray      ;     warn_co=$yellow     ; ;;

        low2)
         inst_co=$cyan       ;  mark_co=$rev_co    ;     grep_co="1"
         bold_co=$white      ;    fs_co=$gray      ;      num_co=$white      ;
         date_co=$gray       ;  head_co=$white     ;    quest_co=$green      ;
          dev_co=$white      ;    hi_co=$white     ;     quit_co=$green      ;
          err_co=$red        ;   lab_co=$gray      ;  version_co=$white      ;
        fname_co=$white      ;     m_co=$gray      ;     warn_co=$yellow     ; ;;

        bw)
         inst_co=$white      ;  mark_co=$rev_co    ;     grep_co="1;37"
         bold_co=$white      ;    fs_co=$gray      ;      num_co=$white      ;
         date_co=$gray       ;  head_co=$white     ;    quest_co=$white      ;
          dev_co=$white      ;    hi_co=$white     ;     quit_co=$white      ;
          err_co=$white      ;   lab_co=$lt_gray   ;  version_co=$lt_gray    ;
        fname_co=$white      ;     m_co=$gray      ;     warn_co=$white      ; ;;

        *)
            fatal "Unknown color scheme: %s" "$scheme"
    esac
}

#------------------------------------------------------------------------------
#
#
#------------------------------------------------------------------------------
read_all_cmdline_mingled() {

    : ${PARAM_CNT:=0}
    SHIFT_2=0

    while [ $# -gt 0 ]; do
        read_params "$@"
        shift $SHIFT
        SHIFT_2=$((SHIFT_2 + SHIFT))
        [ -n "$END_CMDLINE" ] && return
        while [ $# -gt 0 -a ${#1} -gt 0 -a -n "${1##-*}" ]; do
            PARAM_CNT=$((PARAM_CNT + 1))
            assign_parameter $PARAM_CNT "$1"
            shift
            SHIFT_2=$((SHIFT_2 + 1))
        done
    done
}

#------------------------------------------------------------------------------
#
#
#------------------------------------------------------------------------------
check_param_cnt() {
    local max=$1 ; shift
    [ $# -le $max ] && return
    fatal "Unexpected command line parameter(s): %s" "$*"
}

#------------------------------------------------------------------------------
#
#
#------------------------------------------------------------------------------
read_params() {
    # Most of this code is boiler-plate for parsing cmdline args
    SHIFT=0
    # These are the single-char options that can stack

    local arg val

    # Loop through the cmdline args
    while [ $# -gt 0 -a ${#1} -gt 0 -a -z "${1##-*}" ]; do
        arg=${1#-} ; shift
        SHIFT=$((SHIFT + 1))

        # Expand stacked single-char arguments
        case $arg in
            [$SHORT_STACK][$SHORT_STACK]*)
                if echo "$arg" | grep -q "^[$SHORT_STACK]\+$"; then
                    local old_cnt=$#
                    set -- $(echo $arg | sed -r 's/([a-zA-Z])/ -\1 /g') "$@"
                    SHIFT=$((SHIFT - $# + old_cnt))
                    continue
                fi;;
        esac

        # Deal with all options that take a parameter
        if takes_param "$arg"; then
            [ $# -lt 1 ] && fatal $"Expected a parameter after: %s" "-$arg"
            val=$1
            [ -n "$val" -a -z "${val##-*}" ] \
                && fatal $"Suspicious argument after %s: %s" "-$arg" "$val"
            SHIFT=$((SHIFT + 1))
            shift
        else
            case $arg in
                *=*)  val=${arg#*=} ;;
                  *)  val="???"     ;;
            esac
        fi

        eval_argument "$arg" "$val"
        [ "$END_CMDLINE" ] && return
    done
}

#------------------------------------------------------------------------------
#
#
#------------------------------------------------------------------------------
show_version() {
    local fmt="$hi_co%s$nc_co %s$num_co %s$nc_co ($date_co%s$nc_co)\n"
    printf "$fmt" "$ME" "version" "$VERSION"  "$VERSION_DATE"

    [ $# -gt 0 ]  && exit 0
}



main "$@"
